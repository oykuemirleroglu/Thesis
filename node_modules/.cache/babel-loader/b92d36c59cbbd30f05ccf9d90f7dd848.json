{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useClockEvents;\n\nvar _react = require(\"react\");\n\nvar _constants = require(\"../helpers/constants\");\n\nvar _dom = require(\"../helpers/dom\");\n\nvar _math = require(\"../helpers/math\");\n\nconst {\n  atan2\n} = Math;\n/*\n\tsolely responsible for transforming click events into\n\tangles (which are later converted into time depending\n\ton current mode and other restrictions)\n*/\n\nfunction useClockEvents(clock, handleChange) {\n  const wrapper = (0, _react.useRef)(null);\n  const calcOffsetCache = (0, _react.useRef)(null);\n  const dragCount = (0, _react.useRef)(0);\n  const cleanupRef = (0, _react.useRef)(() => {}); // avoid recomputing all the event listeners, prolly unnecessary...\n\n  const handleChangeRef = (0, _react.useRef)(handleChange);\n  (0, _react.useEffect)(() => {\n    handleChangeRef.current = handleChange;\n  }, [handleChange]);\n  const calculatePoint = (0, _react.useCallback)((offsetX, offsetY, canAutoChangeMode) => {\n    // if user just clicks/taps a number (drag count < 2), then just assume it's a rough tap\n    // and force a rounded/coarse number (ie: 1, 2, 3, 4 is tapped, assume 0 or 5)\n    const wasTapped = dragCount.current < 2;\n    const x = offsetX - _constants.CLOCK_RADIUS;\n    const y = -offsetY + _constants.CLOCK_RADIUS;\n    const a = atan2(y, x);\n    let d = 90 - (0, _math.deg)(a);\n\n    if (d < 0) {\n      d = 360 + d;\n    } // ensure touch doesn't bleed outside of clock radius\n\n\n    if (!(0, _math.isWithinRadius)(x, y, _constants.CLOCK_RADIUS) && wasTapped) {\n      return false;\n    }\n\n    const isInnerClick = (0, _math.isWithinRadius)(x, y, _constants.INNER_NUMBER_RADIUS); // update time on main\n\n    handleChangeRef.current(d, {\n      canAutoChangeMode,\n      wasTapped,\n      isInnerClick\n    });\n  }, []); // handle mouse + touch changes\n\n  const handleMouseUp = (0, _react.useCallback)(e => {\n    if (!clock.current) {\n      return;\n    }\n\n    clock.current.style.cursor = '';\n    const {\n      offsetX,\n      offsetY\n    } = calcOffsetCache.current(e.clientX, e.clientY);\n    calculatePoint(offsetX, offsetY, true);\n  }, [calculatePoint, clock]);\n  const handleTouchEnd = (0, _react.useCallback)(e => {\n    const touch = e.targetTouches[0] || e.changedTouches[0];\n\n    if (touch && calcOffsetCache.current) {\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(touch.clientX, touch.clientY);\n      calculatePoint(offsetX, offsetY, true);\n    }\n  }, [calculatePoint]);\n  const handleMouseDrag = (0, _react.useCallback)(e => {\n    if (calcOffsetCache.current) {\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(e.clientX, e.clientY);\n      calculatePoint(offsetX, offsetY, false);\n    }\n\n    dragCount.current++;\n\n    if (dragCount.current === 1 && clock.current) {\n      clock.current.style.cursor = '-webkit-grabbing';\n      clock.current.style.cursor = 'grabbing';\n    }\n\n    e.preventDefault();\n    return false;\n  }, [calculatePoint, clock]);\n  const handleTouchDrag = (0, _react.useCallback)(e => {\n    if (calcOffsetCache.current) {\n      const touch = e.targetTouches[0];\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(touch.clientX, touch.clientY);\n      calculatePoint(offsetX, offsetY, false);\n    }\n\n    dragCount.current++;\n    e.preventDefault();\n    return false;\n  }, [calculatePoint]); // stop mouse + touch events\n\n  const handleStopDrag = (0, _react.useCallback)(e => {\n    cleanupRef.current();\n\n    if (e == null || clock.current == null) {\n      return;\n    }\n\n    if (isMouseEventEnd(e)) {\n      handleMouseUp(e);\n    } else if (isTouchEventEnd(e)) {\n      handleTouchEnd(e);\n    }\n\n    function isMouseEventEnd(e) {\n      return e.type === 'mouseup';\n    }\n\n    function isTouchEventEnd(e) {\n      return e.type === 'touchcancel' || e.type === 'touchend';\n    }\n  }, [handleMouseUp, handleTouchEnd, clock]); // mouse events\n\n  const handleMouseDown = (0, _react.useCallback)(e => {\n    dragCount.current = 0; // terminate if click is outside of clock radius, ie:\n    // if clicking meridiem button which overlaps with clock\n\n    if (clock.current) {\n      calcOffsetCache.current = (0, _dom.calcOffset)(clock.current);\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(e.clientX, e.clientY);\n      const x = offsetX - _constants.CLOCK_RADIUS;\n      const y = offsetY - _constants.CLOCK_RADIUS;\n      if (!(0, _math.isWithinRadius)(x, y, _constants.CLOCK_RADIUS)) return;\n    } // add listeners\n\n\n    document.addEventListener('mousemove', handleMouseDrag, false);\n    document.addEventListener('mouseup', handleStopDrag, false);\n    wrapper.current && wrapper.current.addEventListener('mouseleave', handleStopDrag, false); // @ts-ignore\n\n    handleMouseDrag(e);\n  }, [clock, handleMouseDrag, handleStopDrag]); // touch events\n\n  const handleTouchStart = (0, _react.useCallback)(e => {\n    e.preventDefault();\n    dragCount.current = 0; // add listeners\n\n    document.addEventListener('touchmove', handleTouchDrag, false);\n    document.addEventListener('touchend', handleStopDrag, false);\n    document.addEventListener('touchcancel', handleStopDrag, false);\n\n    if (clock.current) {\n      calcOffsetCache.current = (0, _dom.calcOffset)(clock.current);\n    }\n  }, [clock, handleStopDrag, handleTouchDrag]); // attach touchstart event manually to the clock to make it cancelable.\n\n  (0, _react.useEffect)(() => {\n    const currentTarget = clock.current;\n    const type = 'touchstart';\n\n    if (currentTarget) {\n      currentTarget.addEventListener(type, handleTouchStart, false);\n    }\n\n    return () => {\n      if (currentTarget) {\n        currentTarget.removeEventListener(type, handleTouchStart, false);\n      }\n    };\n  }, [clock, handleTouchStart]);\n  /*\n  \tdeals with circular dependencies of callback functions; add listener function\n  \tdepends on remove listener function and vice versa\n  \ton remove listener function which depends on the add listener cb\n  */\n\n  (0, _react.useEffect)(() => {\n    cleanupRef.current = () => {\n      document.removeEventListener('mousemove', handleMouseDrag, false);\n      document.removeEventListener('mouseup', handleStopDrag, false);\n      wrapper.current && wrapper.current.removeEventListener('mouseleave', handleStopDrag, false);\n      document.removeEventListener('touchmove', handleTouchDrag, false);\n      document.removeEventListener('touchend', handleStopDrag, false);\n      document.removeEventListener('touchcancel', handleStopDrag, false);\n    };\n  }, [handleMouseDrag, handleStopDrag, handleTouchDrag]); // clean up\n\n  (0, _react.useEffect)(() => {\n    return cleanupRef.current;\n  }, []);\n  return {\n    bind: {\n      onMouseDown: handleMouseDown,\n      ref: wrapper\n    }\n  };\n}","map":{"version":3,"sources":["C:/Users/Öykü/Desktop/CENG-416/node_modules/react-timekeeper/lib/hooks/useClockEvents.js"],"names":["Object","defineProperty","exports","value","default","useClockEvents","_react","require","_constants","_dom","_math","atan2","Math","clock","handleChange","wrapper","useRef","calcOffsetCache","dragCount","cleanupRef","handleChangeRef","useEffect","current","calculatePoint","useCallback","offsetX","offsetY","canAutoChangeMode","wasTapped","x","CLOCK_RADIUS","y","a","d","deg","isWithinRadius","isInnerClick","INNER_NUMBER_RADIUS","handleMouseUp","e","style","cursor","clientX","clientY","handleTouchEnd","touch","targetTouches","changedTouches","handleMouseDrag","preventDefault","handleTouchDrag","handleStopDrag","isMouseEventEnd","isTouchEventEnd","type","handleMouseDown","calcOffset","document","addEventListener","handleTouchStart","currentTarget","removeEventListener","bind","onMouseDown","ref"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,cAAlB;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,OAAD,CAApB;;AAEA,IAAIC,UAAU,GAAGD,OAAO,CAAC,sBAAD,CAAxB;;AAEA,IAAIE,IAAI,GAAGF,OAAO,CAAC,gBAAD,CAAlB;;AAEA,IAAIG,KAAK,GAAGH,OAAO,CAAC,iBAAD,CAAnB;;AAEA,MAAM;AACJI,EAAAA;AADI,IAEFC,IAFJ;AAIA;AACA;AACA;AACA;AACA;;AACA,SAASP,cAAT,CAAwBQ,KAAxB,EAA+BC,YAA/B,EAA6C;AAC3C,QAAMC,OAAO,GAAG,CAAC,GAAGT,MAAM,CAACU,MAAX,EAAmB,IAAnB,CAAhB;AACA,QAAMC,eAAe,GAAG,CAAC,GAAGX,MAAM,CAACU,MAAX,EAAmB,IAAnB,CAAxB;AACA,QAAME,SAAS,GAAG,CAAC,GAAGZ,MAAM,CAACU,MAAX,EAAmB,CAAnB,CAAlB;AACA,QAAMG,UAAU,GAAG,CAAC,GAAGb,MAAM,CAACU,MAAX,EAAmB,MAAM,CAAE,CAA3B,CAAnB,CAJ2C,CAIM;;AAEjD,QAAMI,eAAe,GAAG,CAAC,GAAGd,MAAM,CAACU,MAAX,EAAmBF,YAAnB,CAAxB;AACA,GAAC,GAAGR,MAAM,CAACe,SAAX,EAAsB,MAAM;AAC1BD,IAAAA,eAAe,CAACE,OAAhB,GAA0BR,YAA1B;AACD,GAFD,EAEG,CAACA,YAAD,CAFH;AAGA,QAAMS,cAAc,GAAG,CAAC,GAAGjB,MAAM,CAACkB,WAAX,EAAwB,CAACC,OAAD,EAAUC,OAAV,EAAmBC,iBAAnB,KAAyC;AACtF;AACA;AACA,UAAMC,SAAS,GAAGV,SAAS,CAACI,OAAV,GAAoB,CAAtC;AACA,UAAMO,CAAC,GAAGJ,OAAO,GAAGjB,UAAU,CAACsB,YAA/B;AACA,UAAMC,CAAC,GAAG,CAACL,OAAD,GAAWlB,UAAU,CAACsB,YAAhC;AACA,UAAME,CAAC,GAAGrB,KAAK,CAACoB,CAAD,EAAIF,CAAJ,CAAf;AACA,QAAII,CAAC,GAAG,KAAK,CAAC,GAAGvB,KAAK,CAACwB,GAAV,EAAeF,CAAf,CAAb;;AAEA,QAAIC,CAAC,GAAG,CAAR,EAAW;AACTA,MAAAA,CAAC,GAAG,MAAMA,CAAV;AACD,KAXqF,CAWpF;;;AAGF,QAAI,CAAC,CAAC,GAAGvB,KAAK,CAACyB,cAAV,EAA0BN,CAA1B,EAA6BE,CAA7B,EAAgCvB,UAAU,CAACsB,YAA3C,CAAD,IAA6DF,SAAjE,EAA4E;AAC1E,aAAO,KAAP;AACD;;AAED,UAAMQ,YAAY,GAAG,CAAC,GAAG1B,KAAK,CAACyB,cAAV,EAA0BN,CAA1B,EAA6BE,CAA7B,EAAgCvB,UAAU,CAAC6B,mBAA3C,CAArB,CAlBsF,CAkBA;;AAEtFjB,IAAAA,eAAe,CAACE,OAAhB,CAAwBW,CAAxB,EAA2B;AACzBN,MAAAA,iBADyB;AAEzBC,MAAAA,SAFyB;AAGzBQ,MAAAA;AAHyB,KAA3B;AAKD,GAzBsB,EAyBpB,EAzBoB,CAAvB,CAV2C,CAmCnC;;AAER,QAAME,aAAa,GAAG,CAAC,GAAGhC,MAAM,CAACkB,WAAX,EAAwBe,CAAC,IAAI;AACjD,QAAI,CAAC1B,KAAK,CAACS,OAAX,EAAoB;AAClB;AACD;;AAEDT,IAAAA,KAAK,CAACS,OAAN,CAAckB,KAAd,CAAoBC,MAApB,GAA6B,EAA7B;AACA,UAAM;AACJhB,MAAAA,OADI;AAEJC,MAAAA;AAFI,QAGFT,eAAe,CAACK,OAAhB,CAAwBiB,CAAC,CAACG,OAA1B,EAAmCH,CAAC,CAACI,OAArC,CAHJ;AAIApB,IAAAA,cAAc,CAACE,OAAD,EAAUC,OAAV,EAAmB,IAAnB,CAAd;AACD,GAXqB,EAWnB,CAACH,cAAD,EAAiBV,KAAjB,CAXmB,CAAtB;AAYA,QAAM+B,cAAc,GAAG,CAAC,GAAGtC,MAAM,CAACkB,WAAX,EAAwBe,CAAC,IAAI;AAClD,UAAMM,KAAK,GAAGN,CAAC,CAACO,aAAF,CAAgB,CAAhB,KAAsBP,CAAC,CAACQ,cAAF,CAAiB,CAAjB,CAApC;;AAEA,QAAIF,KAAK,IAAI5B,eAAe,CAACK,OAA7B,EAAsC;AACpC,YAAM;AACJG,QAAAA,OADI;AAEJC,QAAAA;AAFI,UAGFT,eAAe,CAACK,OAAhB,CAAwBuB,KAAK,CAACH,OAA9B,EAAuCG,KAAK,CAACF,OAA7C,CAHJ;AAIApB,MAAAA,cAAc,CAACE,OAAD,EAAUC,OAAV,EAAmB,IAAnB,CAAd;AACD;AACF,GAVsB,EAUpB,CAACH,cAAD,CAVoB,CAAvB;AAWA,QAAMyB,eAAe,GAAG,CAAC,GAAG1C,MAAM,CAACkB,WAAX,EAAwBe,CAAC,IAAI;AACnD,QAAItB,eAAe,CAACK,OAApB,EAA6B;AAC3B,YAAM;AACJG,QAAAA,OADI;AAEJC,QAAAA;AAFI,UAGFT,eAAe,CAACK,OAAhB,CAAwBiB,CAAC,CAACG,OAA1B,EAAmCH,CAAC,CAACI,OAArC,CAHJ;AAIApB,MAAAA,cAAc,CAACE,OAAD,EAAUC,OAAV,EAAmB,KAAnB,CAAd;AACD;;AAEDR,IAAAA,SAAS,CAACI,OAAV;;AAEA,QAAIJ,SAAS,CAACI,OAAV,KAAsB,CAAtB,IAA2BT,KAAK,CAACS,OAArC,EAA8C;AAC5CT,MAAAA,KAAK,CAACS,OAAN,CAAckB,KAAd,CAAoBC,MAApB,GAA6B,kBAA7B;AACA5B,MAAAA,KAAK,CAACS,OAAN,CAAckB,KAAd,CAAoBC,MAApB,GAA6B,UAA7B;AACD;;AAEDF,IAAAA,CAAC,CAACU,cAAF;AACA,WAAO,KAAP;AACD,GAlBuB,EAkBrB,CAAC1B,cAAD,EAAiBV,KAAjB,CAlBqB,CAAxB;AAmBA,QAAMqC,eAAe,GAAG,CAAC,GAAG5C,MAAM,CAACkB,WAAX,EAAwBe,CAAC,IAAI;AACnD,QAAItB,eAAe,CAACK,OAApB,EAA6B;AAC3B,YAAMuB,KAAK,GAAGN,CAAC,CAACO,aAAF,CAAgB,CAAhB,CAAd;AACA,YAAM;AACJrB,QAAAA,OADI;AAEJC,QAAAA;AAFI,UAGFT,eAAe,CAACK,OAAhB,CAAwBuB,KAAK,CAACH,OAA9B,EAAuCG,KAAK,CAACF,OAA7C,CAHJ;AAIApB,MAAAA,cAAc,CAACE,OAAD,EAAUC,OAAV,EAAmB,KAAnB,CAAd;AACD;;AAEDR,IAAAA,SAAS,CAACI,OAAV;AACAiB,IAAAA,CAAC,CAACU,cAAF;AACA,WAAO,KAAP;AACD,GAbuB,EAarB,CAAC1B,cAAD,CAbqB,CAAxB,CA/E2C,CA4FrB;;AAEtB,QAAM4B,cAAc,GAAG,CAAC,GAAG7C,MAAM,CAACkB,WAAX,EAAwBe,CAAC,IAAI;AAClDpB,IAAAA,UAAU,CAACG,OAAX;;AAEA,QAAIiB,CAAC,IAAI,IAAL,IAAa1B,KAAK,CAACS,OAAN,IAAiB,IAAlC,EAAwC;AACtC;AACD;;AAED,QAAI8B,eAAe,CAACb,CAAD,CAAnB,EAAwB;AACtBD,MAAAA,aAAa,CAACC,CAAD,CAAb;AACD,KAFD,MAEO,IAAIc,eAAe,CAACd,CAAD,CAAnB,EAAwB;AAC7BK,MAAAA,cAAc,CAACL,CAAD,CAAd;AACD;;AAED,aAASa,eAAT,CAAyBb,CAAzB,EAA4B;AAC1B,aAAOA,CAAC,CAACe,IAAF,KAAW,SAAlB;AACD;;AAED,aAASD,eAAT,CAAyBd,CAAzB,EAA4B;AAC1B,aAAOA,CAAC,CAACe,IAAF,KAAW,aAAX,IAA4Bf,CAAC,CAACe,IAAF,KAAW,UAA9C;AACD;AACF,GApBsB,EAoBpB,CAAChB,aAAD,EAAgBM,cAAhB,EAAgC/B,KAAhC,CApBoB,CAAvB,CA9F2C,CAkHC;;AAE5C,QAAM0C,eAAe,GAAG,CAAC,GAAGjD,MAAM,CAACkB,WAAX,EAAwBe,CAAC,IAAI;AACnDrB,IAAAA,SAAS,CAACI,OAAV,GAAoB,CAApB,CADmD,CAC5B;AACvB;;AAEA,QAAIT,KAAK,CAACS,OAAV,EAAmB;AACjBL,MAAAA,eAAe,CAACK,OAAhB,GAA0B,CAAC,GAAGb,IAAI,CAAC+C,UAAT,EAAqB3C,KAAK,CAACS,OAA3B,CAA1B;AACA,YAAM;AACJG,QAAAA,OADI;AAEJC,QAAAA;AAFI,UAGFT,eAAe,CAACK,OAAhB,CAAwBiB,CAAC,CAACG,OAA1B,EAAmCH,CAAC,CAACI,OAArC,CAHJ;AAIA,YAAMd,CAAC,GAAGJ,OAAO,GAAGjB,UAAU,CAACsB,YAA/B;AACA,YAAMC,CAAC,GAAGL,OAAO,GAAGlB,UAAU,CAACsB,YAA/B;AACA,UAAI,CAAC,CAAC,GAAGpB,KAAK,CAACyB,cAAV,EAA0BN,CAA1B,EAA6BE,CAA7B,EAAgCvB,UAAU,CAACsB,YAA3C,CAAL,EAA+D;AAChE,KAbkD,CAajD;;;AAGF2B,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,WAA1B,EAAuCV,eAAvC,EAAwD,KAAxD;AACAS,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,SAA1B,EAAqCP,cAArC,EAAqD,KAArD;AACApC,IAAAA,OAAO,CAACO,OAAR,IAAmBP,OAAO,CAACO,OAAR,CAAgBoC,gBAAhB,CAAiC,YAAjC,EAA+CP,cAA/C,EAA+D,KAA/D,CAAnB,CAlBmD,CAkBuC;;AAE1FH,IAAAA,eAAe,CAACT,CAAD,CAAf;AACD,GArBuB,EAqBrB,CAAC1B,KAAD,EAAQmC,eAAR,EAAyBG,cAAzB,CArBqB,CAAxB,CApH2C,CAyIG;;AAE9C,QAAMQ,gBAAgB,GAAG,CAAC,GAAGrD,MAAM,CAACkB,WAAX,EAAwBe,CAAC,IAAI;AACpDA,IAAAA,CAAC,CAACU,cAAF;AACA/B,IAAAA,SAAS,CAACI,OAAV,GAAoB,CAApB,CAFoD,CAE7B;;AAEvBmC,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,WAA1B,EAAuCR,eAAvC,EAAwD,KAAxD;AACAO,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,UAA1B,EAAsCP,cAAtC,EAAsD,KAAtD;AACAM,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,aAA1B,EAAyCP,cAAzC,EAAyD,KAAzD;;AAEA,QAAItC,KAAK,CAACS,OAAV,EAAmB;AACjBL,MAAAA,eAAe,CAACK,OAAhB,GAA0B,CAAC,GAAGb,IAAI,CAAC+C,UAAT,EAAqB3C,KAAK,CAACS,OAA3B,CAA1B;AACD;AACF,GAXwB,EAWtB,CAACT,KAAD,EAAQsC,cAAR,EAAwBD,eAAxB,CAXsB,CAAzB,CA3I2C,CAsJG;;AAE9C,GAAC,GAAG5C,MAAM,CAACe,SAAX,EAAsB,MAAM;AAC1B,UAAMuC,aAAa,GAAG/C,KAAK,CAACS,OAA5B;AACA,UAAMgC,IAAI,GAAG,YAAb;;AAEA,QAAIM,aAAJ,EAAmB;AACjBA,MAAAA,aAAa,CAACF,gBAAd,CAA+BJ,IAA/B,EAAqCK,gBAArC,EAAuD,KAAvD;AACD;;AAED,WAAO,MAAM;AACX,UAAIC,aAAJ,EAAmB;AACjBA,QAAAA,aAAa,CAACC,mBAAd,CAAkCP,IAAlC,EAAwCK,gBAAxC,EAA0D,KAA1D;AACD;AACF,KAJD;AAKD,GAbD,EAaG,CAAC9C,KAAD,EAAQ8C,gBAAR,CAbH;AAcA;AACF;AACA;AACA;AACA;;AAEE,GAAC,GAAGrD,MAAM,CAACe,SAAX,EAAsB,MAAM;AAC1BF,IAAAA,UAAU,CAACG,OAAX,GAAqB,MAAM;AACzBmC,MAAAA,QAAQ,CAACI,mBAAT,CAA6B,WAA7B,EAA0Cb,eAA1C,EAA2D,KAA3D;AACAS,MAAAA,QAAQ,CAACI,mBAAT,CAA6B,SAA7B,EAAwCV,cAAxC,EAAwD,KAAxD;AACApC,MAAAA,OAAO,CAACO,OAAR,IAAmBP,OAAO,CAACO,OAAR,CAAgBuC,mBAAhB,CAAoC,YAApC,EAAkDV,cAAlD,EAAkE,KAAlE,CAAnB;AACAM,MAAAA,QAAQ,CAACI,mBAAT,CAA6B,WAA7B,EAA0CX,eAA1C,EAA2D,KAA3D;AACAO,MAAAA,QAAQ,CAACI,mBAAT,CAA6B,UAA7B,EAAyCV,cAAzC,EAAyD,KAAzD;AACAM,MAAAA,QAAQ,CAACI,mBAAT,CAA6B,aAA7B,EAA4CV,cAA5C,EAA4D,KAA5D;AACD,KAPD;AAQD,GATD,EASG,CAACH,eAAD,EAAkBG,cAAlB,EAAkCD,eAAlC,CATH,EA5K2C,CAqLa;;AAExD,GAAC,GAAG5C,MAAM,CAACe,SAAX,EAAsB,MAAM;AAC1B,WAAOF,UAAU,CAACG,OAAlB;AACD,GAFD,EAEG,EAFH;AAGA,SAAO;AACLwC,IAAAA,IAAI,EAAE;AACJC,MAAAA,WAAW,EAAER,eADT;AAEJS,MAAAA,GAAG,EAAEjD;AAFD;AADD,GAAP;AAMD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = useClockEvents;\n\nvar _react = require(\"react\");\n\nvar _constants = require(\"../helpers/constants\");\n\nvar _dom = require(\"../helpers/dom\");\n\nvar _math = require(\"../helpers/math\");\n\nconst {\n  atan2\n} = Math;\n\n/*\n\tsolely responsible for transforming click events into\n\tangles (which are later converted into time depending\n\ton current mode and other restrictions)\n*/\nfunction useClockEvents(clock, handleChange) {\n  const wrapper = (0, _react.useRef)(null);\n  const calcOffsetCache = (0, _react.useRef)(null);\n  const dragCount = (0, _react.useRef)(0);\n  const cleanupRef = (0, _react.useRef)(() => {}); // avoid recomputing all the event listeners, prolly unnecessary...\n\n  const handleChangeRef = (0, _react.useRef)(handleChange);\n  (0, _react.useEffect)(() => {\n    handleChangeRef.current = handleChange;\n  }, [handleChange]);\n  const calculatePoint = (0, _react.useCallback)((offsetX, offsetY, canAutoChangeMode) => {\n    // if user just clicks/taps a number (drag count < 2), then just assume it's a rough tap\n    // and force a rounded/coarse number (ie: 1, 2, 3, 4 is tapped, assume 0 or 5)\n    const wasTapped = dragCount.current < 2;\n    const x = offsetX - _constants.CLOCK_RADIUS;\n    const y = -offsetY + _constants.CLOCK_RADIUS;\n    const a = atan2(y, x);\n    let d = 90 - (0, _math.deg)(a);\n\n    if (d < 0) {\n      d = 360 + d;\n    } // ensure touch doesn't bleed outside of clock radius\n\n\n    if (!(0, _math.isWithinRadius)(x, y, _constants.CLOCK_RADIUS) && wasTapped) {\n      return false;\n    }\n\n    const isInnerClick = (0, _math.isWithinRadius)(x, y, _constants.INNER_NUMBER_RADIUS); // update time on main\n\n    handleChangeRef.current(d, {\n      canAutoChangeMode,\n      wasTapped,\n      isInnerClick\n    });\n  }, []); // handle mouse + touch changes\n\n  const handleMouseUp = (0, _react.useCallback)(e => {\n    if (!clock.current) {\n      return;\n    }\n\n    clock.current.style.cursor = '';\n    const {\n      offsetX,\n      offsetY\n    } = calcOffsetCache.current(e.clientX, e.clientY);\n    calculatePoint(offsetX, offsetY, true);\n  }, [calculatePoint, clock]);\n  const handleTouchEnd = (0, _react.useCallback)(e => {\n    const touch = e.targetTouches[0] || e.changedTouches[0];\n\n    if (touch && calcOffsetCache.current) {\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(touch.clientX, touch.clientY);\n      calculatePoint(offsetX, offsetY, true);\n    }\n  }, [calculatePoint]);\n  const handleMouseDrag = (0, _react.useCallback)(e => {\n    if (calcOffsetCache.current) {\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(e.clientX, e.clientY);\n      calculatePoint(offsetX, offsetY, false);\n    }\n\n    dragCount.current++;\n\n    if (dragCount.current === 1 && clock.current) {\n      clock.current.style.cursor = '-webkit-grabbing';\n      clock.current.style.cursor = 'grabbing';\n    }\n\n    e.preventDefault();\n    return false;\n  }, [calculatePoint, clock]);\n  const handleTouchDrag = (0, _react.useCallback)(e => {\n    if (calcOffsetCache.current) {\n      const touch = e.targetTouches[0];\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(touch.clientX, touch.clientY);\n      calculatePoint(offsetX, offsetY, false);\n    }\n\n    dragCount.current++;\n    e.preventDefault();\n    return false;\n  }, [calculatePoint]); // stop mouse + touch events\n\n  const handleStopDrag = (0, _react.useCallback)(e => {\n    cleanupRef.current();\n\n    if (e == null || clock.current == null) {\n      return;\n    }\n\n    if (isMouseEventEnd(e)) {\n      handleMouseUp(e);\n    } else if (isTouchEventEnd(e)) {\n      handleTouchEnd(e);\n    }\n\n    function isMouseEventEnd(e) {\n      return e.type === 'mouseup';\n    }\n\n    function isTouchEventEnd(e) {\n      return e.type === 'touchcancel' || e.type === 'touchend';\n    }\n  }, [handleMouseUp, handleTouchEnd, clock]); // mouse events\n\n  const handleMouseDown = (0, _react.useCallback)(e => {\n    dragCount.current = 0; // terminate if click is outside of clock radius, ie:\n    // if clicking meridiem button which overlaps with clock\n\n    if (clock.current) {\n      calcOffsetCache.current = (0, _dom.calcOffset)(clock.current);\n      const {\n        offsetX,\n        offsetY\n      } = calcOffsetCache.current(e.clientX, e.clientY);\n      const x = offsetX - _constants.CLOCK_RADIUS;\n      const y = offsetY - _constants.CLOCK_RADIUS;\n      if (!(0, _math.isWithinRadius)(x, y, _constants.CLOCK_RADIUS)) return;\n    } // add listeners\n\n\n    document.addEventListener('mousemove', handleMouseDrag, false);\n    document.addEventListener('mouseup', handleStopDrag, false);\n    wrapper.current && wrapper.current.addEventListener('mouseleave', handleStopDrag, false); // @ts-ignore\n\n    handleMouseDrag(e);\n  }, [clock, handleMouseDrag, handleStopDrag]); // touch events\n\n  const handleTouchStart = (0, _react.useCallback)(e => {\n    e.preventDefault();\n    dragCount.current = 0; // add listeners\n\n    document.addEventListener('touchmove', handleTouchDrag, false);\n    document.addEventListener('touchend', handleStopDrag, false);\n    document.addEventListener('touchcancel', handleStopDrag, false);\n\n    if (clock.current) {\n      calcOffsetCache.current = (0, _dom.calcOffset)(clock.current);\n    }\n  }, [clock, handleStopDrag, handleTouchDrag]); // attach touchstart event manually to the clock to make it cancelable.\n\n  (0, _react.useEffect)(() => {\n    const currentTarget = clock.current;\n    const type = 'touchstart';\n\n    if (currentTarget) {\n      currentTarget.addEventListener(type, handleTouchStart, false);\n    }\n\n    return () => {\n      if (currentTarget) {\n        currentTarget.removeEventListener(type, handleTouchStart, false);\n      }\n    };\n  }, [clock, handleTouchStart]);\n  /*\n  \tdeals with circular dependencies of callback functions; add listener function\n  \tdepends on remove listener function and vice versa\n  \ton remove listener function which depends on the add listener cb\n  */\n\n  (0, _react.useEffect)(() => {\n    cleanupRef.current = () => {\n      document.removeEventListener('mousemove', handleMouseDrag, false);\n      document.removeEventListener('mouseup', handleStopDrag, false);\n      wrapper.current && wrapper.current.removeEventListener('mouseleave', handleStopDrag, false);\n      document.removeEventListener('touchmove', handleTouchDrag, false);\n      document.removeEventListener('touchend', handleStopDrag, false);\n      document.removeEventListener('touchcancel', handleStopDrag, false);\n    };\n  }, [handleMouseDrag, handleStopDrag, handleTouchDrag]); // clean up\n\n  (0, _react.useEffect)(() => {\n    return cleanupRef.current;\n  }, []);\n  return {\n    bind: {\n      onMouseDown: handleMouseDown,\n      ref: wrapper\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}